{"version":3,"file":"index.js","mappings":";;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../webpack://mean-dao-publish/../../../../../opt/homebrew/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://mean-dao-publish/external node-commonjs \"util\"","../webpack://mean-dao-publish/webpack/bootstrap","../webpack://mean-dao-publish/webpack/runtime/compat","../webpack://mean-dao-publish/./src/index.js"],"sourcesContent":[null,"module.exports = require(\"util\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","const util = require('util');\nconst axios = require(\"axios\");\nconst fse = require('fs-extra');\nconst core = require('@actions/core');\nconst github = require('@actions/github');\nconst changelogParser = require('changelog-parser');\nconst npmFetch = require('npm-registry-fetch');\nconst npmPublish = require('@jsdevtools/npm-publish');\n\nconst fetchNpmVersions = async (packageName, token) => {\n    const { versions } = await npmFetch.json(\n        `http://registry.npmjs.org/${packageName}`,\n        { token });\n    const list = Object.values(versions).map(({ version }) => String(version));\n    return list;\n};\n\nconst parseChangelog = util.promisify(changelogParser);\n\nasync function run() {\n    try {\n        const github_token = core.getInput('github_token', { required: true });\n        const discord_webhook = core.getInput('discord_webhook');\n        const gchat_webhook = core.getInput('gchat_webhook');\n        const npm_token = core.getInput('npm_token');\n        const access = core.getInput('access');\n        const path = core.getInput('path') ?? `.`;\n        const octokit = github.getOctokit(github_token);\n\n        const pathToPackage = `${path}/package.json`;\n\n        const pkg = await fse.readJSON(pathToPackage);\n        if (!pkg) {\n            throw Error(`${pathToPackage} is missing`);\n        }\n\n        const name = pkg.name;\n        if (!name) {\n            throw Error(`Name in ${pathToPackage} is missing`);\n        }\n\n        const version = pkg.version;\n        if (!version) {\n            throw Error(`Version in ${pathToPackage} is missing`);\n        }\n\n        const tag = `v${version}`;\n\n        core.info(`\\nChecking ${tag}`);\n\n        const owner = github.context.repo.owner;\n        const repo = github.context.repo.repo;\n\n        let npmPublishTag = '';\n        let tagResponse = { data: {} };\n        try {\n            core.info(`Getting release tag ${tag}..`);\n            tagResponse = await octokit.request('GET /repos/{owner}/{repo}/releases/tags/{tag}', {\n                owner,\n                repo,\n                tag,\n            });\n        } catch (err) {\n            core.info(`tagResponse:error:`, err);\n        }\n\n        let previousVersion = '';\n        try {\n            core.info(`Getting last tag..`);\n            const tagList = await octokit.request('GET /repos/{owner}/{repo}/tags', {\n                owner,\n                repo,\n            });\n\n            previousVersion = tagList.data.filter(x => x.name !== tag)[0].name\n\n            core.info(`previousVersion: ${previousVersion}`);\n        } catch (err) {\n            core.info(`previousVersion:error:`, err);\n        }\n\n        let commits = [];\n        try {\n            core.info(`Getting last tag..`);\n            const commitList = await octokit.request('GET /repos/{owner}/{repo}/compare/{basehead}', {\n                owner,\n                repo,\n                basehead: `${previousVersion}...HEAD`\n            });\n\n            commits = commitList.data.commits.map(x => `[${x.commit.author.name}] ${x.commit.message}`);\n\n            core.info(`commits: ${commits}`);\n        } catch (err) {\n            core.info(`commits:error:`, err);\n        }\n\n        const canRelease = !tagResponse.data.tag_name;\n        const isProductionVersion = tag.match(/^v([0-9]|[1-9][0-9]*)\\.([0-9]|[1-9][0-9]*)\\.([0-9]|[1-9][0-9]*)$/gm);\n        const isPrerelease = isProductionVersion === null;\n        if (isPrerelease) {\n            npmPublishTag = 'alpha';\n            if (version.match(/beta|rc/)) {\n                npmPublishTag = 'beta';\n            }\n        }\n\n        core.info(`*** isProductionVersion: ${isProductionVersion}, isPrerelease: ${isPrerelease} ***`);\n\n        let notificationMsg = {\n            packageName: name,\n            isPrerelease\n        }\n\n        if (canRelease) {\n            let releaseNotes = { body: `Publish version ${tag}\\n` };\n            const changelogPath = `${path}/CHANGELOG.md`;\n            if (fse.existsSync(changelogPath)) {\n                const changelog = await parseChangelog(changelogPath);\n                releaseNotes = changelog.versions[0];\n            }\n\n            if (commits.length > 0) {\n                releaseNotes.body += '### Commits\\n';\n                releaseNotes.body += commits.map(x => `- ${x}`).join('\\n');\n            }\n\n            await octokit.request('POST /repos/{owner}/{repo}/releases', {\n                owner,\n                repo,\n                target_commitish: github.context.ref.split('refs/heads/')[1],\n                tag_name: tag,\n                name: tag,\n                body: releaseNotes.body,\n                prerelease: isPrerelease,\n            });\n\n            const githubReleaseUrl = `https://github.com/${owner}/${repo}/releases/tag/${tag}`;\n            if (gchat_webhook || discord_webhook) {\n                notificationMsg = {\n                    ...notificationMsg,\n                    githubReleaseUrl\n                };\n            }\n            core.info(`Release notes created: ${githubReleaseUrl}`);\n        } else {\n            core.info('Release is already exist. Nothing to do here');\n        }\n\n        if (npm_token) {\n            let canPublish;\n            try {\n                const npmVersions = await fetchNpmVersions(name, npm_token);\n                canPublish = !npmVersions.includes(version); // new version\n            } catch {\n                canPublish = true; // new package\n            }\n\n            if (canPublish) {\n                await npmPublish.npmPublish({\n                    token: npm_token,\n                    access: access || 'public',\n                    tag: npmPublishTag || 'latest'\n                });\n\n                const npmRegistyUrl = `https://www.npmjs.com/package/${name}`;\n                if (gchat_webhook || discord_webhook) {\n                    notificationMsg = {\n                        ...notificationMsg,\n                        npmRegistyUrl\n                    };\n                }\n\n                core.info(`Published to npm registry: ${npmRegistyUrl}`);\n            } else {\n                core.info('Package version is already exist. Nothing to do here');\n            }\n\n            if (gchat_webhook || discord_webhook) {\n                try {\n                    core.info(`Sending notification...`);\n\n                    let msg = `*NEW VERSION RELEASED (${version})* \\n`;\n                    //developers.google.com/chat/api/guides/message-formats/basic#using_formatted_text_in_messages\n                    Object.keys(notificationMsg).forEach(x => {\n                        msg += `*${x}* : ${notificationMsg[x]} \\n`\n                    });\n\n                    if (gchat_webhook) {\n                        await axios.default.post(gchat_webhook, { text: msg });\n                    }\n\n                    if (discord_webhook) {\n                        await axios.default.post(discord_webhook, { content: msg });\n                    }\n\n                    core.info(`Notification sent!`);\n                } catch (error) {\n                    core.info(`Webhook notification failed. Error: ${error}`)\n                }\n            }\n        }\n    } catch (error) {\n        core.setFailed(error.message);\n    }\n}\n\nrun();\n"],"names":[],"sourceRoot":""}